//#region keep-alive
/* 
  keep-alive 长链接
    keep-alive是客户端与服务端的约定，keep-alive开启后，客户端与服务端通信完成后不会马上断开连接，旨在能服用上一个TCP连接
    keep-alive的控制在请求(响应)头中 Connection：keep-alive
    Http1.0 需要通过请求头开启长链接，Http1.1长链接默认开启

    注意：持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起，如果上次的请求还没返回响应内容，下次请求就只能等着（就是常说的线头阻塞）
*/
//#endregion

//#region http状态码
/* 
  1xx:(信息类)
    100:服务器已经收到初始部分，客户端应该继续发送剩余部分
    101：切换不同的协议通信
  2xx:(成功类)
    200：成功，返回请求内容
    201：成功，服务器上创建了新的资源
    204：成功，但没有内容返回
  3xx:(重定向类)
    301：永久重定向，请求的内容已经永久转移到别的位置了
    302：临时重定向，请求的内容临时移动到别的位置
    304：客户端可以使用的缓存内容，协商缓存
  4xx:(客户端错误类)
    400：请求参数错误，服务端无法理解
    401：请求的用户需要认证
    404：请求的资源不存在
  5xx:(服务端错误类)
    500：服务器遇到一个未预期的错误
    502：网关服务器或代理服务器无法从上游服务器获取到内容
    503：服务器无法处理当前请求
*/
//#endregion

//#region http 1、2、3
/* 
  http 1 和 2
    1 采用纯文本的形式传输，2采用二进制格式传输数据
    1 请求头带有大量信息，并且会重复发送，2 在客户端和服务端使用首部表跟踪和存储，对于相同的数据，不再重复请求和发送
    1 存在线头阻塞的问题，上一个请求未结束，下一个请求需要等待，2 支持多路复用，允许一个TCP连接中发送多个请求，而且不会受上一个请求的阻塞影响

    http 3
     1 和 2 都是 TCP协议，3是UDP协议
     彻底解决TCP队头阻塞问题
     集成TLS加密功能
     向前纠错机制
*/
//#endregion

//#region Https握手过程
/* 
  （1）直接简单加密（对称加密）
      加密和解密都使用同一个密钥，密钥一般就在加密数据的前几个字节
      弊端：大家都知道的规则，等于没加密
  （2）非对称加密
      一个公开的密钥，一个私有的密钥，公钥加密只能用私钥解密，私钥加密只能用公钥解密
      服务端会把公钥发给客户端，客户端使用服务端给的公钥进行加密，服务端用私钥解密，服务端用私钥加密数据，客户端用公钥解密
      弊端：加密解密费时间
  （3）对称加密和非对称加密结合
      还是一个公钥，一个私钥，服务端将公钥发给客户端，客户端用公钥加密密钥给服务端，服务端用私钥解密密码，后面就一直用该密钥进行通信
  （4）提升加密的安全性
      客户端给服务端发送一个随机数据，服务端给客户端发送一个随机数据，然后客户段使用公钥加密一个随机数据，服务端用私钥解密后，利用三个随机数
      生成密钥进行通信
      弊端：无法防范中间人攻击
      中间人攻击：客户端与服务端之间有一个中间的服务端，此时客户端认为中间的服务端是服务端，服务端认为中间人是客户端，此时这一套加密方式将会失效
  （5）数字证书
      服务端去公证人去进行登记，将公钥和名字等信息上报，公证人拿这些信息计算hash，再用公证人的私钥对hash进行加密，生成数字签名
      服务端将自己的公钥和名字等信息加上数字签名生成数字证书与客户段通信
      客户端对数字证书进行验证，通过服务端发送过来的公钥和名字等信息计算hash，再通过公证人的公钥解密数字签名，比对两个hash进行身份验证
  （6）信任链
      由于服务端的数量过多，全部到公证人处生成数字证书不符合实际，让所有的公证人自己给自己签发证书，称为根证书，安装在操作系统中，通过信任链判断证书是否有效，验证签发者是否在根证书列表中


*/
//#endregion
