/*
    从一个url地址到最终的页面生成,发生了什么
    1.DNS解析:将域名地址解析为ip地址

      -浏览器DNS缓存
      -系统DNS缓存
      -路由器DNS缓存
      -网络运营商DNS缓存
      -递归搜索:blog.baidu.com
            -.com域名下查找DNS解析
            -.baidu域名下查找DNS解析
            -blog域名下查找DNS解析
            -出错了
    2.TCP连接:TCP三次握手
        -第一次握手，由浏览器发起，告诉服务器我要发送请求了
        -第二次握手，由服务器发起，告诉浏览器我准备接受了
        -第三次握手，由浏览器发送，告诉服务器，我马上就发了
    3．发送请求
        –请求报文:HTTP协议的通信内容
    4．接受响应
        -响应报文
    5．渲染页面
        –遇见HTML标记，浏览器调用HTML解析器解析成Token并构建成don树
        -遇见style/link标记，浏览器调用css解析器，处理css标记并构建cssom树
        -遇到script标记，调用javascript解析器，处理script代码（绑定事件，修改dom树/cssom树)
        -将dom树和cssom树合并成一个渲染树
        -根据渲染树来计算布局，计算每个节点的几何信息(布局)
        -将各个节点颜色绘制到屏幕上（渲染)
    - 注意;
        这个五个步骤不一定按照顺序执行，如果dom树或cssom树被修改了，
        可能会执行多次布局和渲染往往实际页面中，这些步骤都会执行多次的。
    6．断开连接:TCP四次挥手
      -第一次挥手:由浏览器发起的，发送给服务器，我东西发送完了（请求报文)，你准备关闭吧
      -第二次挥手:由服务器发起的，告诉浏览器，我东西接受完了(请求报文），我准备关闭了，你也准备吧
      -第三次挥手:由服务器发起，告诉浏览器，我东西发送完了（响应报文)，你准备关闭吧
      -第四次挥手:由浏览器发起，告诉服务器，我东西接受完了，我准备关闭了（响应报文)，你也准备吧


    详解：

      （1）解析URL：检测主机名、协议是否合法，是否出现非法字符

      - URL组成部分：协议部分、域名部分、端口部分、虚拟目录、文件、锚点、参数

      （2）缓存判断

      - 强缓存：不用请求服务器，直接使用本地的缓存。

        - 强缓存是利用 http 响应头中的**`Expires`**或**`Cache-Control`**实现的
        - **注意**：这两个response header属性可以只启用一个，也可以同时启用。当response header中，Expires和Cache-Control同时存在时，**Cache-Control的优先级高于Expires**。
        - **`Expires`**：服务器返回的**绝对时间**
        - **`Cache-Control`**：服务器返回的**相对时间**

      - 协商缓存：浏览器发现本地有资源的副本，但是不太确定要不要使用，于是去问问服务器。

        - 协商缓存是利用的是两对Header：

          - 第一对：`Last-Modified`、`If-Modified-Since`

          - 第二对：`ETag`、`If-None-Match`

          - Last-Modified、If-Modified-Since

            （1）浏览器第一次请求一个资源，服务器在返回这个资源的同时，会加上`Last-Modified`这个 response header，这个header表示这该资源在服务器上的最后修改时间

            （2）浏览器再次请求这个资源时，会加上`If-Modified-Since`这个 request header，这个header的值就是上一次返回的`Last-Modified`的值

            （3）服务器收到第二次请求时，会比对浏览器传过来的`If-Modified-Since`和资源在服务器上的最后修改时间`Last-Modified`，判断资源是否有变化。如果没有变化则返回304 Not Modified，但不返回资源内容（此时，服务器不会返回 Last-Modified 这个 response header）；如果有变化，就正常返回资源内容（继续重复整个流程）

            （4）浏览器如果收到304的响应，就会从缓存中加载资源。

          - ETag、If-None-Match

            （1）浏览器第一次请求一个资源，服务器在返回这个资源的同时，会加上`ETag`这个 response header，这个header是服务器根据当前请求的资源生成的**唯一标识**。这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间无关，所以也就很好地补充了`Last-Modified`的不足

            （2）浏览器再次请求这个资源时，会加上`If-None-Match`这个 request header，这个header的值就是上一次返回的`ETag`的值

            （3）服务器第二次请求时，会对比浏览器传过来的`If-None-Match`和服务器重新生成的一个新的`ETag`，判断资源是否有变化。如果没有变化则返回304 Not Modified，但不返回资源内容（此时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag并无变化）。如果有变化，就正常返回资源内容（继续重复整个流程）

            （4）浏览器如果收到304的响应，就会从缓存中加载资源。

      （3）DNS解析

      - 在浏览器的缓存中找对应的IP地址，若有缓存，返回IP地址，没有则向本地的DNS服务器发起请求（递归查询）
      - 本地服务器没有则向根服务器查询
      - 根服务器没有，本地服务器向权威服务器查询（迭代查询）

      （4）获取MAC地址：根据IP地址，通过ARP协议获取对应的MAC地址

      （5）TCP三次握手

      - 第一次：客户端发送请求连接报文、SYN = 1
      - 第二次：服务器收到请求连接报文，给服务器发送连接报文和确认报文，SYN=1、ACK=1
      - 第三次：客户端收到服务器发送的连接报文，向服务器发送确认报文，ACK = 1

      为什么需要三次握手？需要确认双方接收和发送都没有问题

      如果只进行两次握手会发生什么？可能会造成资源浪费、可能会造成死锁

      （6）HTTPS握手：SSL/TLS四次握手

      - 直接加密（对称加密）：以数据的前几个字节作为密钥，加密和解密都使用同一个密钥，在其使用者多起来之后，就相当于没有加密
      - 非对称加密：服务端和客户端都有一个公钥和一个私钥，并且公钥加密的内容只有私钥能解开
        - 单向解密：通信前，服务器先将公钥发送给客户端，客户端使用服务器发送的公钥加密数据，再将数据发送给服务器，由服务器的私钥进行解密
        - 双向解密：通信前，服务器和客户端相互交换公钥，相互发送数据的时，使用对方的公钥进行加密，弊端：解密和加密耗费时间过长，对用户而言是很不好的体验，并且占用很多的资源都在加密和解密上了
      - 非对称加密和对称加密结合
        - 服务器向客户端发送服务器的公钥，客户端使用服务器的公钥进行加密，加密的内容是后面加密和解密都要使用到的密钥
      - 秘钥计算
        - 客户端像服务器发送一个随机数字1，服务器收到后，将数字保存下来，并且给客户端发送公钥和随机数字2
        - 客户端收到后，将随机数字2保存下来，并利用收到的服务器公钥加密随机数字3，将加密的数据给服务器发送过去
        - 服务器收到加密的数据后，利用私钥进行解密，获得随机数字3，然后服务器和客户端都使用这三个随机数字组成的密钥进行加密解密
        - 存在的问题：可能会存在中间人，拦截掉所有的通信。
      - 数字证书（认证机制）
        - 服务器先去公证人那里登记，将公钥和信息交给公证人，公证人将这些信息生成一个hash值，在利用公证人的私钥加密hash值，这就是数字签名
        - 公证人将信息和数字签名进行封装打包发回给服务器，这个就是数字证书
        - 服务器跟客户端通信的时候，将数据证书发给客户端，客户端拿到数字证书后，将里面的信息计算一遍hash值，再利用提前记录好的公证人公钥将数字前面中的内容解密，对比两个hash值，如果两个hash值一致，则认为是同一个服务器
      - 信任链
        - 大家约定，让所有的一代目公证人自己给自己签发一个证书，叫做**根证书**，并安装在我们的操作系统中。

      （7）返回数据：返回一个HTML文件

      （8）渲染数据

      - 构造DOM树，构造CSSOM树，有script标签，判断是否有defer或async，没有script加载执行，DOM树和CSSOM树生成渲染树，进行布局，布局完成后进行绘制

      （9）TCP四次握手

      - 第一次：客户端发送断开连接报文，FIN = 1
      - 第二次：服务器收到报文后，发送确认确认报文，ACK = 1，但此时并没有断开连接，服务器可能还有数据没有发送完
      - 第三次：服务器发送完数据后，发送断开连接报文，FIN = 1，此时服务器等待确认报文
      - 第四次：客户端收到报文后，发送确认报文，ACK = 1，服务器收到后断开连接，客户端等待2msl后断开连接

      为什么要等待2msl呢？保证服务器收到了客户端发送的确认报文
    */
