/**
 * 什么是闭包?
 *    1.密闭的容器.类似于set,map
 *    2.闭包是一个对象.存放数据的格式:key:value
 * 形成的条件:
 *    1.函数嵌套
 *    2.内部函数引用外部函数的局部变量
 * 
 * 闭包的优点:
 *    1.延长外部函数局部变量的生命周期
 * 闭包的缺点:
 *    容易造成内存泄漏
 * 注意点:
 *    1.合理使用闭包
 *    2.用完闭包要及时销毁
 */


// function fun() {
//   var count = 1;
//   // 此时已经形成闭包了
//   function fun2() {
//     console.log(count);
//   }
//   // 在fun2执行之后,闭包会被立即销毁
//   fun2()
// }
// fun()

// function fun() {
//   var count = 1;
//   return function () {
//     count++
//     console.log(count);
//   }
// }

// var fun2 = fun()
// fun2() //2
// fun2() //3

//输出情况
function fun(n, o) {
  // var n ,o
  // fun(0)时 n = 0,o = undefined
  console.log(o)
  return {
    fun: function (m) {
      return fun(m, n)
    }
  }
}
var a = fun(0) //undefined
/* 
  此时fun是一个函数,返回的是全局函数执行的结果,此时m是传入的1,而n则是第一次执行时修改后的0,
  所以此时fun的结果为0,并且此时n是外部函数的局部变量,这里形成了闭包,此时传入的值也只改变了
  返回的函数的值,没有改变外部函数n的值

*/
a.fun(1)  //0 
a.fun(2)  //0
a.fun(3)  //0
/**
 * 这里需要拆开来看,
 * 首先是fun(0) 输出的结果肯定是undefinded
 * 然后是fun(0).fun(1)  此时fun(0)已经给n赋值了,因此输出的是0
 * 然后是(fun(0).fun(1)).fun(2) 此时(fun(0).fun(1))返回的闭包与fun(0)返回的是新的对象,执行新的函数,
 *                             形成新的闭包, 因此,此时相当于n的值应该是1
 * 然后是(fun(0).fun(1).fun(2)).fun(3) 与上面同理
 */
var b = fun(0).fun(1).fun(2).fun(3) //undefined, 0 , 1 , 2
/**
 * 上面两种情况的混合
 * 首先是 fun(0) 输出的结果是undefined
 * 然后是fun(0).fun(1),输出的结果是 0,并将返回对象赋给c
 * 然后是c.fun(2),相当于(fun(0).fun(1)).fun(2),此时的n已经改为1了,输出的是1
 * 然后是c.fun(3),相当于(fun(0).fun(1)).fun(3),此时的n仍然是1,输出1
 */
var c = fun(0).fun(1)
c.fun(2)
c.fun(3) //undefined, 0 ,1 , 1

var test = (function (i) {
  return function () {
    alert(i *= 2);
  }
})(2);
test(5);

// 弹出的是字符串 '4'
/**
 * 这里是一个自调用闭包
 * 外面的函数执行时：
 * 创建一个局部变量i并且赋值为2，然后将一个函数返回出去，将函数赋给test
 * test(5)执行时，实际执行的是第一个函数返回出去的函数，不会执行第一个
 * 函数，第一个函数只会执行一次，由于返回出去的函数不接收变量，因此，传入的5不起作用
 * 并且alert中需要的变量是i，自身函数并没有对应的变量，根据作用域链会在第一个函数中
 * 找到对应的i，i = 2*2 = 4，并且这里形成了闭包，因为返回函数中对外面函数的变量
 * 还有引用，所以外面函数中的变量i在函数执行完之后并不会被销毁
 */
// var a = 0,
//   b = 0;
// function A(a) {
//   A = function (b) {
//     alert(a + b++);
//   };
//   alert(a++);
// }
// A(1); // '1'
// A(2); // '4'

/**
 * 函数执行前进行变量提升，定义 a ，b 未赋值，定义并且对函数赋值
 * 函数执行，全局变量 a 被赋值为 0 ，全局 b被赋值为0
 * A(1)执行，函数的局部变量 a 被赋值为 1 ，此时函数A被重新赋值，弹出执行，弹出 '1' ,并且将局部变量a改为 2
 * A(2)执行，此时函数已经被更改了，执行的是里面的那个函数，因为还用到变量a，自身没有a，根据作用域链
 * 找到外面函数的局部变量a，此时形成了闭包，此时 a = 2 ，b 的值由传入的值决定 ，因此弹出 '4'
 */

var x = 2;
var y = {
  x: 3,
  z: (function (x) {
    this.x *= x;
    x += 2;
    return function (n) {
      this.x *= n;
      x += 3;
      console.log(x);
    }
  })(x)
};
/*
  m(4)此时调用函数的是m,第一个函数是window执行的,this指向的是window,第二个函数是m执行的,m是普通的变量
  this依旧指向window
  自调用函数执行,在函数中会定义var x = 2,局部变量由全局变量赋值,
  因此全局的 x = 2*2 = 6,函数中的x改为 x= 2 + 2=4
  返回一个函数,这个函数由m调用,this指向window,也就是说,全局的 x = 4 * 4 = 16
  返回的函数没有x,会根据作用域链找到第一个函数的 x = 4,此时形成闭包, x = 4 + 3 = 7
  因此打印x=7
*/
var m = y.z;
m(4);
/*
  y.z(5)调用的函数的是y中的z,第一个函数的this指向是window,返回的函数this指向的是y,因为此时执行的函数的是z
  上面的函数执行完之后,形成了闭包,此时全局的x为16,函数内部的x为7
  执行返回的函数:此时this指向的y,this.x = 3 * 5 =15,第一个函数的 x = 7 + 3 =10
  因此打印的x为10
*/

y.z(5);
// 经过两次执行,全局的x已经被改为了16,y中的x被改为了15
console.log(x, y.x);