<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 1、手写instanceof 
    function instanceOf(obj, fn) {
      let proto = obj.__proto__
      if (proto) {
        if (proto === fn.prototype) {
          return true
        } else {
          return instanceOf(proto, fn)
        }
      } else {
        return false
      }
    }

    console.log(instanceOf({}, Array))
    //2、 Object Function
    console.log(Object instanceof Object); //true
    console.log(Function instanceof Function); //true
    console.log(Function instanceof Object); //true
    console.log(function () { } instanceof Function); //true

    // 3、
    function Foo() { }
    // 构造函数的原型对象.constructor === 构造函数
    console.log(Foo.prototype.constructor === Foo) // true
    const f1 = new Foo()
    // 实例对象的原型 === 构造函数的原型对象
    console.log(f1.__proto__ === Foo.prototype) // true

    // 构造函数的原型对象的原型 === Object的原型对象
    console.log(Foo.prototype.__proto__ === Object.prototype) // true
    console.log(Function.prototype.__proto__ === Object.prototype) //true
    // Object的原型对象的原型 === null
    console.log(Object.prototype.__proto__ === null) //true
    // 函数的原型 === Function的原型对象
    console.log(Object.__proto__ === Function.prototype) //true
    console.log(Foo.__proto__ === Function.prototype) // true
    console.log(Function.__proto__ === Function.prototype) // true

    // 4、typeof
    // typeof null === 'object'
    // 原因：对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，
    console.log(typeof null === 'object') //true

    // 5、手写new
    function selfNew(fn, ...args) {
      let instance = Object.create(fn.prototype)

      let res = fn.apply(instance, args)

      return typeof res === 'object' || typeof res === 'function' ? res : instance
    }

    // 6、继承
    // （1）原型链继承，缺点：引用类型的属性会被所有的实例共享
    function SuperClass() { }
    function SubClass() { }
    // 子类构造函数的原型对象指向父类的实例对象
    SubClass.prototype = new SuperClass()
    const instance = new SubClass()

    // （2）盗用构造函数继承
    function SuperClass() { }
    // 每次实例化，都会给父类中的对象都会被初始化，就不存在属性被实例共享的情况，但此时子类是无法访问父类的原型对象的
    function SubClass() {
      SubClass.call(this)
    }
    const instance1 = new SubClass()
    const instance2 = new SubClass()

    // （3）组合式继承
    // 结合原型链继承和盗用构造函数继承的优点
    // 缺点：父类构造函数会执行两遍
    function SuperClass() { }
    function SubClass() {
      SuperClass.call(this)
    }
    SubClass.prototype = new SuperClass()

    const instance3 = new SubClass()

    // （4）原型式继承
    // 原型链继承的封装，未解决引用类型的属性会被所有的实例共享
    function inheritObject(o) {
      function F() { }
      F.prototype = o
      return new F()
    }

    // （5）寄生式继承
    function createObject(obj) {
      let o = inheritObject(obj)
      // 在这可以添加自定义的属性和方法
      return o
    }

    // （6）寄生组合式继承
    function inheritProtype(subClass, superClass) {
      let p = inheritObject(superClass.prototype)
      p.constructor = subClass
      subClass.prototype = p
    }

  </script>
</body>

</html>