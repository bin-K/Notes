/* 
  1、性能上： Vue3 比 Vue2 快 1.2 ~ 2 倍
  2、vue3 使用 proxy 代替 Vue 2 的 Object.defineProperty, 解决 Vue2新增和删除属性监听不到的问题，同时不需要对数组方法进行拦截处理
  3、diff 方法优化：vue3 新增了静态标记，虚拟节点对比时，就只会对比这些带有静态标记的节点
  4、

*/

/* 

proxy相比于Object.defineProperty性能的提升有哪些
 1、初始化性能优化：Vue 2 在初始化响应式数据时，会递归遍历对象的所有属性并使用 Object.defineProperty 
    为每个属性添加 getter 和 setter。这样的初始化过程会产生大量的 getter 和 setter，对于大规模的对象或数据，
    初始化时间会较长。而在 Vue 3 中，使用 Proxy 对象进行拦截，初始化性能得到了显著提升，
    因为 Proxy 是在整个对象级别上进行拦截，无需遍历每个属性。
2）深层属性监听优化：在 Vue 2 中，对于深层嵌套的属性，需要通过递归方式为每个属性添加响应式处理，这在大型对象上可能会导致性能下降。
    而在 Vue 3 中，Proxy 可以递归地拦截整个对象的操作，无需为每个属性单独处理，从而提高了深层属性监听的性能。
3）删除属性性能优化：在 Vue 2 中，当删除一个属性时，需要通过 Vue.$delete 或者 Vue.delete 方法来触发更新。
    这是因为 Vue 2 使用的 Object.defineProperty 无法拦截属性的删除操作。
    而在 Vue 3 中，使用 Proxy 可以直接拦截属性的删除操作，从而简化了删除属性的处理逻辑，并提高了性能。
4）动态添加属性性能优化：在 Vue 2 中，动态添加新属性需要通过 Vue.set 方法来触发更新，否则新添加的属性将不会是响应式的。
    而在 Vue 3 中，Proxy 可以直接拦截动态添加属性的操作，并将其设置为响应式属性，无需额外的处理方法，提高了性能和代码的简洁性。

*/
